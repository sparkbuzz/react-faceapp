{"version":3,"sources":["app/styles.module.scss","components/emoticon/styles.module.scss","components/face-landmarks-overlay/styles.module.scss","components/webcam-video/enums.ts","hooks/use-face-landmarks/use-face-landmarks.tsx","hooks/use-window-size/use-window-size.tsx","utils/draw/index.ts","components/emoticon/emoticon.tsx","components/face-landmarks-overlay/face-landmarks-overlay.tsx","components/webcam-video/webcam-video.tsx","app/app.tsx","reportWebVitals.ts","index.tsx"],"names":["module","exports","MediaElementReadyState","intervalId","isBusyEstimating","hasResizeListener","useWindowSize","useState","width","window","innerWidth","height","innerHeight","windowSize","setWindowSize","useEffect","handleWindowResize","debounce","addEventListener","drawDot","ctx","x","y","fillRect","Emoticon","forwardRef","flip","style","ref","current","innerHTML","JSON","parse","transform","className","styles","emoticon","FaceLandmarksOverlay","drawPointCloud","srcObject","canvasRef","useRef","eyeLRef","eyeRRef","context","setContext","leftIrisPosition","setLeftIrisPosition","rightIrisPosition","setRightIrisPosition","predictions","model","setModel","setPredictions","estimateFaces","a","readyState","HAVE_ENOUGH_DATA","input","flipHorizontal","handleInterval","faceLandmarksDetection","mediapipeFacemesh","maxFaces","then","clearInterval","setInterval","useFaceLandmarks","getContext","Error","canvas","offsetWidth","offsetHeight","configureContext","clearRect","clearCanvas","scaleWidth","videoWidth","scaleHeight","videoHeight","fillStyle","i","length","points","scaledMesh","j","renderPointCloud","offsetX","offsetY","prediction","annotations","leftEyeIris","offsetLeft","offsetTop","rightEyeIris","updateEmoticons","classNames","top","left","WebcamVideo","onReadyStateChange","innerRef","videoElement","handleLoadedData","event","target","removeEventListener","constraints","audio","video","facingMode","ideal","navigator","mediaDevices","getUserMedia","stream","catch","error","name","console","log","autoPlay","App","videoIsReady","setVideoIsReady","wrapper","cover","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.07b27230.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"wrapper\":\"styles_wrapper__2Kat_\",\"cover\":\"styles_cover__LVGb0\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"emoticon\":\"styles_emoticon__1BMFv\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"canvas\":\"styles_canvas__bHHcy\"};","enum MediaElementReadyState {\n  HAVE_NOTHING,\n  HAVE_META_DATA,\n  HAVE_CURRENT_DATA,\n  HAVE_FUTURE_DATA,\n  HAVE_ENOUGH_DATA\n}\n\nexport { MediaElementReadyState };\n","import * as faceLandmarksDetection from '@tensorflow-models/face-landmarks-detection';\nimport { FaceLandmarksPackage, FaceLandmarksPrediction } from '@tensorflow-models/face-landmarks-detection';\nimport '@tensorflow/tfjs-backend-webgl';\nimport { RefObject, useEffect, useState } from 'react';\nimport { MediaElementReadyState } from '../../components/webcam-video/enums';\n\nconst PREDICTIONS_PER_SECOND = 30;\n\nlet intervalId: number | null = null;\nlet isBusyEstimating: boolean = false;\n\nconst useFaceLandmarks = (srcObject: RefObject<HTMLVideoElement>) => {\n  const [model, setModel] = useState<FaceLandmarksPackage | null>(null);\n  const [predictions, setPredictions] = useState<FaceLandmarksPrediction[]>();\n\n  useEffect(() => {\n    if (model || srcObject.current?.readyState !== MediaElementReadyState.HAVE_ENOUGH_DATA) {\n      return;\n    }\n\n    loadTensorFlowModel();\n\n    function loadTensorFlowModel () {\n      faceLandmarksDetection.load(\n        faceLandmarksDetection.SupportedPackages.mediapipeFacemesh,\n        {\n          maxFaces: 1\n        }\n      ).then(model => {\n        setModel(model);\n      });\n    }\n\n    return function cleanup () {\n      if (intervalId) window.clearInterval();\n    }\n  }, [model, srcObject]);\n\n  startInterval();\n\n  async function estimateFaces () {\n    if (isBusyEstimating ||\n      !srcObject?.current ||\n      srcObject.current.readyState !== MediaElementReadyState.HAVE_ENOUGH_DATA) {\n      return;\n    }\n\n    isBusyEstimating = true;\n\n    const predictions = await model?.estimateFaces({\n      input: srcObject.current,\n      flipHorizontal: false\n    })\n    setPredictions(predictions);\n\n    isBusyEstimating = false;\n  }\n\n  async function handleInterval () {\n    await estimateFaces();\n  }\n\n  function startInterval () {\n    if (!intervalId && model) {\n      intervalId = window.setInterval(handleInterval, 1000 / PREDICTIONS_PER_SECOND);\n    }\n  }\n\n  return predictions;\n}\n\nexport { useFaceLandmarks };\n","import { useEffect, useState } from 'react';\nimport { debounce } from 'debounce';\n\ntype WindowSize = {\n  height: number,\n  width: number\n}\n\nconst DEBOUNCE_TIMEOUT_MS = 200;\n\nlet hasResizeListener: boolean = false;\n\nconst useWindowSize = (): WindowSize => {\n  const [windowSize, setWindowSize] = useState<WindowSize>({\n    width: window.innerWidth,\n    height: window.innerHeight\n  });\n\n  useEffect(() => {\n    const handleWindowResize = debounce(() => {\n      setWindowSize({\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    }, DEBOUNCE_TIMEOUT_MS);\n\n    if (!hasResizeListener) {\n      window.addEventListener('resize', handleWindowResize);\n      hasResizeListener = true;\n    }\n  }, []);\n\n  return windowSize;\n}\n\nexport { useWindowSize };\nexport type { WindowSize };\n","const drawDot = (ctx: CanvasRenderingContext2D, x: number, y: number) => {\n  ctx.fillRect(x - 1, y - 1, 2, 2);\n}\n\nexport { drawDot };\n","import React, { forwardRef, HTMLAttributes, useEffect } from 'react';\nimport styles from './styles.module.scss';\n\ntype Props = {\n  flip?: boolean\n} & HTMLAttributes<HTMLDivElement>;\n\nconst Emoticon = forwardRef(\n  ({ flip, style }: Props, forwardRef) => {\n    const ref = (forwardRef as React.RefObject<HTMLDivElement>);\n\n    useEffect(() => {\n      if (ref.current) {\n        const obj = { text: `&#128065;` };\n        ref.current.innerHTML = JSON.parse(`\"${obj.text}\"`);\n      }\n    }, [ref]);\n\n    if (!style) style = {};\n    if (flip) style.transform = 'scaleX(-1)';\n\n    return <div style={style} className={styles.emoticon} ref={ref}/>;\n  }\n);\n\nexport { Emoticon };\n","import classNames from 'classnames';\nimport React, { HTMLAttributes, RefObject, useEffect, useRef, useState } from 'react';\nimport { useFaceLandmarks } from '../../hooks/use-face-landmarks';\nimport { useWindowSize } from '../../hooks/use-window-size';\nimport { drawDot } from '../../utils/draw';\nimport { Emoticon } from '../emoticon';\nimport styles from './styles.module.scss';\nimport type { FaceLandmarkPredictions } from './types';\n\ntype Props = {\n  srcObject: RefObject<HTMLVideoElement>,\n  drawPointCloud?: boolean\n} & HTMLAttributes<HTMLElement>;\n\nconst FaceLandmarksOverlay = ({ className, drawPointCloud, srcObject }: Props) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const eyeLRef = useRef<HTMLDivElement>(null);\n  const eyeRRef = useRef<HTMLDivElement>(null);\n\n  const [context, setContext] = useState<CanvasRenderingContext2D | null>(null);\n  const [leftIrisPosition, setLeftIrisPosition] = useState({ x: 0, y: 0 });\n  const [rightIrisPosition, setRightIrisPosition] = useState({ x: 0, y: 0 });\n\n  const predictions = useFaceLandmarks(srcObject);\n  const { width, height } = useWindowSize();\n\n  useEffect(() => {\n    if (predictions) {\n      configureContext();\n      if (!context) return;\n      clearCanvas();\n\n      const scaleWidth = context.canvas.offsetWidth / (srcObject.current as HTMLVideoElement).videoWidth;\n      const scaleHeight = context.canvas.offsetHeight / (srcObject.current as HTMLVideoElement).videoHeight;\n\n      if (drawPointCloud) {\n        renderPointCloud(scaleWidth, scaleHeight);\n      }\n      updateEmoticons(scaleWidth, scaleHeight);\n    }\n\n    function clearCanvas () {\n      if (!context || !canvasRef) return;\n      context.clearRect(0, 0, canvasRef.current?.width || 0, canvasRef.current?.height || 0);\n    }\n\n    function updateEmoticons (scaleWidth: number, scaleHeight: number) {\n      if (!predictions || !srcObject.current) return;\n\n      const offsetX = (eyeLRef.current?.offsetWidth ?? 0) / 2;\n      const offsetY = (eyeRRef.current?.offsetHeight ?? 0) / 2;\n\n      const prediction = predictions[0] as unknown as FaceLandmarkPredictions\n\n      if (prediction.annotations) {\n        let [x, y] = prediction.annotations.leftEyeIris[0];\n        setLeftIrisPosition({\n          x: x * scaleWidth + srcObject.current?.offsetLeft - offsetX,\n          y: y * scaleHeight + srcObject.current?.offsetTop - offsetY\n        });\n\n        [x, y] = prediction.annotations.rightEyeIris[0];\n        setRightIrisPosition({\n          x: x * scaleWidth + srcObject.current?.offsetLeft - offsetX,\n          y: y * scaleHeight + srcObject.current?.offsetTop - offsetY\n        });\n      }\n    }\n\n    function renderPointCloud (scaleWidth: number, scaleHeight: number) {\n      if (!predictions || !context || !srcObject) return;\n\n      context.fillStyle = 'limegreen';\n\n      for (let i = 0; i < predictions.length; i++) {\n        const points: number[][] = (predictions[i] as any)?.scaledMesh;\n\n        for (let j = 0; j < points.length; j++) {\n          const [x, y] = points[j];\n          drawDot(context, x * scaleWidth, y * scaleHeight);\n        }\n      }\n    }\n\n    function configureContext () {\n      if (!canvasRef) return;\n\n      const ctx = canvasRef.current?.getContext('2d')\n      if (!ctx) {\n        throw Error('Attempt to get 2D canvas context failed!');\n      }\n\n      ctx.canvas.width = srcObject.current?.offsetWidth ?? 0;\n      ctx.canvas.height = srcObject.current?.offsetHeight ?? 0;\n\n      setContext(ctx);\n      return ctx;\n    }\n  }, [context, predictions, srcObject, width, height, eyeLRef, eyeRRef]);\n\n  return <>\n    <canvas className={classNames(className, styles.canvas)} ref={canvasRef}/>\n    <Emoticon ref={eyeLRef} flip style={{ top: `${leftIrisPosition.y}px`, left: `${leftIrisPosition.x}px` }}/>\n    <Emoticon ref={eyeRRef} style={{ top: `${rightIrisPosition.y}px`, left: `${rightIrisPosition.x}px` }}/>\n  </>;\n};\n\nexport { FaceLandmarksOverlay };\n","import classNames from 'classnames';\nimport React, { forwardRef, HTMLAttributes, useEffect } from 'react';\nimport { useWindowSize } from '../../hooks/use-window-size';\n\ntype Props = {\n  onReadyStateChange: Function\n} & HTMLAttributes<HTMLVideoElement>;\n\nconst WebcamVideo = forwardRef<HTMLVideoElement, Props>(\n  ({ className, onReadyStateChange }, ref) => {\n    const innerRef = (ref as React.RefObject<HTMLVideoElement>);\n    const { width, height } = useWindowSize();\n\n    useEffect(() => {\n      let videoElement: HTMLVideoElement;\n\n      if (onReadyStateChange && innerRef.current) {\n        videoElement = innerRef.current;\n        const handleLoadedData = (event: Event) => {\n          const readyState = (event.target as HTMLVideoElement).readyState;\n          return onReadyStateChange(readyState);\n        };\n        innerRef.current.addEventListener('loadeddata', handleLoadedData);\n\n        return function cleanup () {\n          videoElement && videoElement.removeEventListener('loadedData', handleLoadedData);\n        }\n      }\n    }, [innerRef, onReadyStateChange]);\n\n    useEffect(() => {\n      const constraints: MediaStreamConstraints = {\n        audio: false,\n        video: {\n          facingMode: { ideal: 'user' },\n          width,\n          height\n        }\n      };\n\n      navigator.mediaDevices.getUserMedia(constraints)\n        .then((stream) => {\n          if (innerRef?.current) {\n            innerRef.current.srcObject = stream;\n          }\n        })\n        .catch((error) => {\n          if (error.name === 'NotAllowedError') {\n            console.log('This app needs permissions to use your camera to run!\\n' +\n              'Please grant the appropriate permissions and reload this page to see some action.');\n          } else {\n            console.error(error);\n          }\n        });\n    }, [width, height, innerRef]);\n\n    return (\n      <video\n        autoPlay\n        className={classNames(className)}\n        ref={innerRef}\n      />\n    );\n  });\n\nexport { WebcamVideo };\n","import React, { useRef, useState } from 'react';\nimport { FaceLandmarksOverlay } from '../components/face-landmarks-overlay';\nimport { WebcamVideo } from '../components/webcam-video';\nimport { MediaElementReadyState } from '../components/webcam-video/enums';\nimport styles from './styles.module.scss';\n\nconst App = () => {\n  const ref = useRef<HTMLVideoElement>(null);\n  const [videoIsReady, setVideoIsReady] = useState<boolean>(false);\n\n  const handleReadyStateChange = (readyState: MediaElementReadyState) => {\n    setVideoIsReady(readyState === MediaElementReadyState.HAVE_ENOUGH_DATA);\n  };\n\n  return (\n    <div className={styles.wrapper}>\n      <WebcamVideo\n        ref={ref}\n        className={styles.cover}\n        onReadyStateChange={handleReadyStateChange}\n      />\n      {videoIsReady && <FaceLandmarksOverlay drawPointCloud={false} srcObject={ref}/>}\n    </div>\n  );\n};\n\nexport { App };\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  // noinspection SuspiciousTypeOfGuard\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from './app';\nimport reportWebVitals from './reportWebVitals';\nimport './index.scss';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App/>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}